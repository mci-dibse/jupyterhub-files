--- /old/opt/conda/lib/python3.7/site-packages/nbgrader/exchange/submit.py
+++ /new/opt/conda/lib/python3.7/site-packages/nbgrader/exchange/submit.py
@@ -1,4 +1,11 @@
 import os
+import shutil
+import logging
+from zeep import Client
+import time
+import base64
+import xml.etree.ElementTree as ET
+
 from stat import (
     S_IRUSR, S_IWUSR, S_IXUSR,
     S_IRGRP, S_IWGRP, S_IXGRP,
@@ -11,7 +18,6 @@ from traitlets import Bool
 from .exchange import Exchange
 from ..utils import get_username, check_mode, find_all_notebooks
 
-
 class ExchangeSubmit(Exchange):
 
     strict = Bool(
@@ -22,6 +28,20 @@ class ExchangeSubmit(Exchange):
         )
     ).tag(config=True)
 
+    def getLogger(self):
+        # logger.getLogger returns the cached logger when called multiple times
+        # logger.Logger created a new one every time and that avoids adding
+        # duplicate handlers
+        logger = logging.getLogger(__name__)
+        if not logger.handlers:
+            logger.setLevel(logging.DEBUG)
+            f_handler = logging.FileHandler(os.path.join('/srv/nbgrader/exchange/', self.course_id  + '/inbound/nbgrader_submit.log'), 'a')
+            f_handler.setLevel(logging.DEBUG)
+            f_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+            f_handler.setFormatter(f_format)
+            logger.addHandler(f_handler)
+        return logger
+
     def init_src(self):
         if self.path_includes_course:
             root = os.path.join(self.course_id, self.coursedir.assignment_id)
@@ -107,11 +127,13 @@ class ExchangeSubmit(Exchange):
         dest_path = os.path.join(self.inbound_path, self.assignment_filename)
         cache_path = os.path.join(self.cache_path, self.assignment_filename)
 
-        self.log.info("Source: {}".format(self.src_path))
-        self.log.info("Destination: {}".format(dest_path))
+        logger = self.getLogger()
+        logger.info("Source: %s", self.src_path)
+        logger.info("Destination: %s", dest_path)
 
         # copy to the real location
         self.check_filename_diff()
+
         self.do_copy(self.src_path, dest_path)
         with open(os.path.join(dest_path, "timestamp.txt"), "w") as fh:
             fh.write(self.timestamp)
@@ -126,6 +148,10 @@ class ExchangeSubmit(Exchange):
             S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH
         )
 
+        if self.create_sakai_submission(dest_path) != 0:
+            shutil.rmtree(dest_path, ignore_errors=True)
+            self.fail("Cannot establish connection to Sakai. Submission was not successful.")
+
         # also copy to the cache
         if not os.path.isdir(self.cache_path):
             os.makedirs(self.cache_path)
@@ -133,6 +159,50 @@ class ExchangeSubmit(Exchange):
         with open(os.path.join(cache_path, "timestamp.txt"), "w") as fh:
             fh.write(self.timestamp)
 
-        self.log.info("Submitted as: {} {} {}".format(
-            self.course_id, self.coursedir.assignment_id, str(self.timestamp)
-        ))
+        logger.info("Submitted as: %s %s %s", self.course_id, self.coursedir.assignment_id, str(self.timestamp))
+
+    def create_sakai_submission(self, dest_path):
+        base_url='https://sakai-dev.mci.edu'
+        login_url = base_url + "/sakai-ws/soap/login?wsdl"
+        script_url = base_url + "/sakai-ws/soap/sakai?wsdl"
+        soap_url='/sakai-ws/soap'
+        assignment_url = base_url + soap_url + "/assignments?wsdl"
+        logger = self.getLogger()
+        #https://sakai.mci4me.at/sakai-ws/soap/login?wsdl
+        try:
+            logger.info("%s", base_url)
+            logger.info("%s", login_url)
+            login_proxy = Client(login_url)
+        except Exception as e:
+            logger.info("Cannot establish connection to webservice: %s", e)
+            return -1
+
+        try:
+            session_id = login_proxy.service.login(id='dae', pw='********')
+            service_proxy = Client(assignment_url)
+            course = os.environ['CONTEXT_ID']
+            body = service_proxy.service.getAssignmentsForContext(session_id, course)
+            root = ET.fromstring(body)
+            for child in root:
+                if child.attrib['title'] == self.coursedir.assignment_id:
+                    assignment_id = child.attrib['id']
+            user_id = os.environ['JUPYTERHUB_USER']
+
+            submission_time = str(int(time.time() * 1000))
+            attachment_name = user_id + "_" + self.coursedir.assignment_id + "_" + submission_time
+            attachment_mime_type = "application/x-zip-compressed"
+            zip_ret = shutil.make_archive(attachment_name, 'zip', dest_path)
+            with open(zip_ret, 'rb') as file_in:
+                bytes = file_in.read()
+                encoded_string = base64.b64encode(bytes)
+
+            os.remove(zip_ret)
+
+            logger.info("Webservice call: %s, %s, %s, %s, %s, %s", session_id, course, assignment_id, user_id, submission_time, attachment_name)
+            ret_val = service_proxy.service.createJupyterSubmission(session_id, course, assignment_id, user_id, submission_time, attachment_name, attachment_mime_type, encoded_string)
+            login_proxy.service.logout(session_id)
+            return 0
+        except Exception as e:
+            logger.info("Exception while sending data to Sakai: %s", e)
+            login_proxy.service.logout(session_id)
+            return -1
